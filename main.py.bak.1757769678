from fastapi import FastAPI, Depends, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from sqlalchemy import func
from dotenv import load_dotenv
import requests

from db import Base, engine, get_db
from models import User, Food, Meal, MealItem, Workout, Set, WeightLog
from schemas import MealIn, WeightIn, WorkoutIn

load_dotenv()
app = FastAPI(title="MacrosCoach API")

# CORS (dev): consenti tutto; in prod limita ai tuoi domini
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Crea tabelle al primo avvio
Base.metadata.create_all(bind=engine)

# ---------- Health ----------
@app.get("/health")
def health():
    return {"ok": True}

# ---------- Helper ----------
def ensure_user(db: Session, user_id: int) -> User:
    """Assicura che l'utente esista; se non c'è crea/usa il demo."""
    u = db.get(User, user_id)
    if not u:
        u = db.query(User).filter_by(email="demo@example.com").first()
        if not u:
            u = User(email="demo@example.com")
            db.add(u)
            db.commit()
            db.refresh(u)
    return u

# ---------- Utenti ----------
@app.post("/users/demo")
def create_demo_user(db: Session = Depends(get_db)):
    u = db.query(User).filter_by(email="demo@example.com").first()
    if not u:
        u = User(email="demo@example.com")
        db.add(u)
        db.commit()
        db.refresh(u)
    return {"user_id": u.id}

# ---------- Barcode ----------
@app.get("/foods/barcode/{code}")
def food_by_barcode(code: str):
    r = requests.get(f"https://world.openfoodfacts.org/api/v2/product/{code}.json", timeout=10)
    j = r.json()
    if j.get("status") != 1:
        raise HTTPException(status_code=404, detail="Barcode non trovato")
    p = j["product"]
    nutr = p.get("nutriments", {})
    return {
        "name": p.get("product_name") or p.get("brands") or "Prodotto",
        "per_100g": {
            "kcal": nutr.get("energy-kcal_100g"),
            "pro": nutr.get("proteins_100g"),
            "carb": nutr.get("carbohydrates_100g"),
            "fat": nutr.get("fat_100g"),
        }
    }

# ---------- Pasti ----------
@app.post("/meals")
def create_meal(
    meal: MealIn,
    db: Session = Depends(get_db),
    user_id: int = Query(default=1, description="ID utente"),
):
    try:
        u = ensure_user(db, user_id)
        m = Meal(user_id=u.id, when=meal.when)
        db.add(m)
        db.flush()
        for it in meal.items:
            db.add(MealItem(
                meal_id=m.id,
                food_name=it.food_name,
                grams=it.grams,
                pro=it.pro, carb=it.carb, fat=it.fat
            ))
        db.commit()
        return {"ok": True, "meal_id": m.id, "user_id": u.id}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Errore create_meal: {e}")

@app.get("/meals/today")
def meals_today(db: Session = Depends(get_db), user_id: int = Query(default=1)):
    from datetime import datetime, timedelta
    ensure_user(db, user_id)
    d0 = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    d1 = d0 + timedelta(days=1)
    meals = db.query(Meal).filter(Meal.user_id==user_id, Meal.when>=d0, Meal.when<d1).order_by(Meal.when.asc()).all()
    result = []
    tot_pro = tot_carb = tot_fat = 0.0
    for m in meals:
        items = db.query(MealItem).filter(MealItem.meal_id==m.id).all()
        pro = sum(i.pro * (i.grams/100) for i in items)
        carb = sum(i.carb * (i.grams/100) for i in items)
        fat = sum(i.fat * (i.grams/100) for i in items)
        kcal = pro*4 + carb*4 + fat*9
        tot_pro += pro; tot_carb += carb; tot_fat += fat
        result.append({
            "meal_id": m.id,
            "when": m.when.isoformat(),
            "kcal": kcal, "pro": pro, "carb": carb, "fat": fat,
            "items": [{"food_name": i.food_name, "grams": i.grams, "pro": i.pro, "carb": i.carb, "fat": i.fat} for i in items]
        })
    day = {"kcal": tot_pro*4 + tot_carb*4 + tot_fat*9, "pro": tot_pro, "carb": tot_carb, "fat": tot_fat}
    return {"day_totals": day, "meals": result}

# ---------- Peso ----------
@app.post("/weight")
def add_weight(
    w: WeightIn,
    db: Session = Depends(get_db),
    user_id: int = Query(default=1, description="ID utente"),
):
    try:
        u = ensure_user(db, user_id)
        db.add(WeightLog(user_id=u.id, when=w.when, kg=w.kg))
        db.commit()
        return {"ok": True, "user_id": u.id}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Errore add_weight: {e}")

@app.get("/weights/all")
def weights_all(db: Session = Depends(get_db), user_id: int = Query(default=1)):
    ensure_user(db, user_id)
    rows = db.query(WeightLog).filter(WeightLog.user_id==user_id).order_by(WeightLog.when.asc()).all()
    return [{"when": r.when.isoformat(), "kg": r.kg} for r in rows]

# ---------- Allenamenti ----------
@app.post("/workouts")
def add_workout(
    w: WorkoutIn,
    db: Session = Depends(get_db),
    user_id: int = Query(default=1, description="ID utente"),
):
    try:
        u = ensure_user(db, user_id)
        wk = Workout(user_id=u.id, when=w.when)
        db.add(wk)
        db.flush()
        for s in w.sets:
            db.add(Set(workout_id=wk.id, exercise=s.exercise, reps=s.reps, weight_kg=s.weight_kg))
        db.commit()
        return {"ok": True, "workout_id": wk.id, "user_id": u.id}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=f"Errore add_workout: {e}")

@app.get("/workouts/all")
def workouts_all(db: Session = Depends(get_db), user_id: int = Query(default=1)):
    ensure_user(db, user_id)
    wks = db.query(Workout).filter(Workout.user_id==user_id).order_by(Workout.when.desc()).all()
    out = []
    for w in wks:
        sets = db.query(Set).filter(Set.workout_id==w.id).all()
        out.append({
            "id": w.id,
            "when": w.when.isoformat(),
            "sets": [{"exercise": s.exercise, "reps": s.reps, "weight_kg": s.weight_kg} for s in sets]
        })
    return out

# ---------- Riepilogo giorno ----------
@app.get("/summary/day")
def summary_day(
    date: str,
    db: Session = Depends(get_db),
    user_id: int = Query(default=1, description="ID utente"),
):
    from datetime import datetime, timedelta
    d0 = datetime.fromisoformat(date)
    d1 = d0 + timedelta(days=1)
    ensure_user(db, user_id)
    pro = db.query(func.sum(MealItem.pro * (MealItem.grams/100))).join(Meal).\
        filter(Meal.user_id==user_id, Meal.when>=d0, Meal.when<d1).scalar() or 0
    carb = db.query(func.sum(MealItem.carb * (MealItem.grams/100))).join(Meal).\
        filter(Meal.user_id==user_id, Meal.when>=d0, Meal.when<d1).scalar() or 0
    fat = db.query(func.sum(MealItem.fat * (MealItem.grams/100))).join(Meal).\
        filter(Meal.user_id==user_id, Meal.when>=d0, Meal.when<d1).scalar() or 0
    kcal = pro*4 + carb*4 + fat*9
    return {"kcal": kcal, "pro": pro, "carb": carb, "fat": fat, "user_id": user_id}

# ---------- Debug ----------
@app.get("/debug/pingdb")
def debug_pingdb(db: Session = Depends(get_db)):
    users = db.query(func.count(User.id)).scalar() or 0
    meals = db.query(func.count(Meal.id)).scalar() or 0
    workouts = db.query(func.count(Workout.id)).scalar() or 0
    weights = db.query(func.count(WeightLog.id)).scalar() or 0
    return {"ok": True, "counts": {"users": users, "meals": meals, "workouts": workouts, "weights": weights}}

# ---------- Utilità: Pasti in intervallo ----------
@app.get("/meals/range")
def meals_range(
    date_from: str,
    date_to: str,
    db: Session = Depends(get_db),
    user_id: int = Query(default=1, description="ID utente"),
):
    from datetime import datetime, timedelta
    ensure_user(db, user_id)
    try:
        d0 = datetime.fromisoformat(date_from)
        d1 = datetime.fromisoformat(date_to) + timedelta(days=1)
    except Exception:
        raise HTTPException(status_code=400, detail="Formato data non valido. Usa YYYY-MM-DD")
    meals = db.query(Meal).filter(Meal.user_id==user_id, Meal.when>=d0, Meal.when<d1).order_by(Meal.when.asc()).all()
    out = []
    for m in meals:
        items = db.query(MealItem).filter(MealItem.meal_id==m.id).all()
        pro = sum(i.pro * (i.grams/100) for i in items)
        carb = sum(i.carb * (i.grams/100) for i in items)
        fat = sum(i.fat * (i.grams/100) for i in items)
        kcal = pro*4 + carb*4 + fat*9
        out.append({
            "meal_id": m.id,
            "when": m.when.isoformat(),
            "kcal": kcal, "pro": pro, "carb": carb, "fat": fat,
            "items": [{"food_name": i.food_name, "grams": i.grams, "pro": i.pro, "carb": i.carb, "fat": i.fat} for i in items]
        })
    return out

# ---------- Utilità: Peso settimanale (media/min/max/n) ----------
@app.get("/weights/weekly")
def weights_weekly(
    db: Session = Depends(get_db),
    user_id: int = Query(default=1, description="ID utente"),
):
    from datetime import timedelta
    ensure_user(db, user_id)
    rows = db.query(WeightLog).filter(WeightLog.user_id==user_id).order_by(WeightLog.when.asc()).all()
    if not rows:
        return []
    # raggruppa per settimana (lunedì come inizio settimana)
    weekly = {}
    for r in rows:
        d = r.when.date()
        week_start = d - timedelta(days=d.weekday())
        key = week_start.isoformat()
        w = weekly.get(key, {"week_start": key, "values": []})
        w["values"].append(r.kg)
        weekly[key] = w
    # calcola statistiche
    out = []
    for k in sorted(weekly.keys()):
        vals = weekly[k]["values"]
        avg = sum(vals)/len(vals)
        out.append({
            "week_start": k,
            "avg": round(avg, 2),
            "min": min(vals),
            "max": max(vals),
            "n": len(vals),
        })
    return out

# ---------- Debug: elimina pesi a 0 ----------
@app.delete("/debug/weights/zero")
def delete_zero_weights(db: Session = Depends(get_db), user_id: int = Query(default=1)):
    ensure_user(db, user_id)
    deleted = db.query(WeightLog).filter(WeightLog.user_id==user_id, WeightLog.kg <= 0).delete()
    db.commit()
    return {"deleted": deleted}
